import re

def extract_info(text):
    email_regex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b|\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[А-Я|а-я]{2,}\b'
    phone_regex = r'\b(?:\+?\d{1,3}[-.\s]?)?\(?(?:\d{3})?\)?[-.\s]?\d{3}[-.\s]?\d{4}\b|\b(?:\+?\d{1,3}[-.\s]?)?\(?(?:\d{3})?\)?[-.\s]?\d{3}[-.\s]?\d{2}[-.\s]?\d{2}\b'
    name_regex = r'[А-Я][а-я]+|[A-Z][a-z]+'
    email = re.findall(email_regex, text)
    phone = re.findall(phone_regex, text)
    name = re.findall(name_regex, text)

    data = {'name': name or None, 'email': email or None, 'phone': phone or None}
    return data

  text = "Меня зовут Марсель, мой адрес электронной почты marselle@example.com, и мой номер телефона +7 (999) 999-9999"
data = extract_info(text)
print(data)

# Этот код теперь использует те же регулярные выражения, что и в предыдущем примере, 
# но в случае если ни одно совпадение не найдено, он сохраняет None в словаре data вместо списка.

# Это делается путем использования оператора `or`, который возвращает первое истинное значение из двух значений, 
# в данном случае, это список с результатами или None.

# Так как регулярные выражения используются в этом примере не подстроены под конкретный формат русских дресов электронной почты и номеров 
# телефонов, возможно, что они не смогут найти все адреса и номера в русском тексте. 
# Чтобы увеличить точность, рекомендуется использовать более конкретные шаблоны и протестировать их с различными примерами русского текста.
